import {
    FileStorageService,
    ProjectFile,
    GeneratedProject,
    NodeConfiguration,
    clientFileStorage,
    serverFileStorage
} from '../file-storage-service';

describe('FileStorageService - Integration Tests', () => {

    describe('Singleton instances', () => {
        it('should export client and server instances', () => {
            expect(clientFileStorage).toBeInstanceOf(FileStorageService);
            expect(serverFileStorage).toBeInstanceOf(FileStorageService);
            expect(clientFileStorage).not.toBe(serverFileStorage);
        });
    });

    describe('AI Integration Methods', () => {
        let service: FileStorageService;

        beforeEach(() => {
            service = new FileStorageService(false);
        });

        it('should have all required AI integration methods', () => {
            expect(typeof service.storeProjectFiles).toBe('function');
            expect(typeof service.createZipArchive).toBe('function');
            expect(typeof service.uploadToSupabase).toBe('function');
            expect(typeof service.getProjectDownloadUrl).toBe('function');
            expect(typeof service.cleanupFailedUpload).toBe('function');
            expect(typeof service.validateProjectFiles).toBe('function');
        });

        it('should validate project files correctly', () => {
            const validFiles: ProjectFile[] = [
                { path: 'package.json', content: '{"name": "test"}', type: 'json' },
                { path: 'main.js', content: 'console.log("test");', type: 'javascript' },
                { path: 'README.md', content: '# Test Project', type: 'markdown' }
            ];

            const result = service.validateProjectFiles(validFiles);
            expect(result.valid).toBe(true);
            expect(result.errors).toHaveLength(0);
        });

        it('should create ZIP archives from project files', async () => {
            const files: ProjectFile[] = [
                { path: 'package.json', content: '{"name": "test-project"}', type: 'json' },
                { path: 'src/index.js', content: 'export default function() {}', type: 'javascript' },
                { path: 'README.md', content: '# Test Project\n\nGenerated by n8n converter', type: 'markdown' }
            ];

            const zipBuffer = await service.createZipArchive(files);

            expect(zipBuffer).toBeInstanceOf(Buffer);
            expect(zipBuffer.length).toBeGreaterThan(100); // Should have some content
        });

        it('should handle complex project structures', async () => {
            const nodeConfig: NodeConfiguration = {
                nodeId: 'http-node-1',
                nodeName: 'HTTP Request Node',
                nodeType: 'n8n-nodes-base.httpRequest',
                parameters: {
                    url: 'https://api.example.com/data',
                    method: 'GET',
                    headers: { 'Content-Type': 'application/json' }
                },
                credentials: { httpBasicAuth: 'my-auth' },
                configuredParameters: [
                    {
                        name: 'url',
                        value: 'https://api.example.com/data',
                        type: 'string',
                        isConfigured: true
                    }
                ],
                environmentVariables: [
                    {
                        key: 'API_URL',
                        description: 'API endpoint URL',
                        required: true,
                        example: 'https://api.example.com'
                    }
                ],
                dependencies: ['axios', 'dotenv']
            };

            const generatedProject: GeneratedProject = {
                projectName: 'complex-workflow',
                files: [
                    {
                        path: 'package.json',
                        content: JSON.stringify({
                            name: 'complex-workflow',
                            dependencies: { axios: '^1.0.0', dotenv: '^16.0.0' }
                        }),
                        type: 'json'
                    },
                    {
                        path: 'main.js',
                        content: `
import HttpRequestNode from './src/nodes/HttpRequestNode.js';

const node = new HttpRequestNode();
console.log('Workflow started with node:', node);
            `,
                        type: 'javascript'
                    },
                    {
                        path: 'src/nodes/HttpRequestNode.js',
                        content: `
class HttpRequestNode {
  constructor() {
    this.url = '${nodeConfig.parameters.url}';
    this.method = '${nodeConfig.parameters.method}';
  }
  
  async execute(inputData) {
    // Implementation here
    return { success: true, data: inputData };
  }
}

export default HttpRequestNode;
            `,
                        type: 'javascript'
                    },
                    {
                        path: '.env.example',
                        content: 'API_URL=https://api.example.com\nAPI_KEY=your_api_key_here',
                        type: 'text'
                    },
                    {
                        path: 'README.md',
                        content: `# Complex Workflow

Generated from n8n workflow with ${nodeConfig.nodeName}.

## Environment Variables

- API_URL: ${nodeConfig.environmentVariables[0].description}

## Dependencies

${nodeConfig.dependencies.map(dep => `- ${dep}`).join('\n')}
            `,
                        type: 'markdown'
                    }
                ],
                dependencies: nodeConfig.dependencies,
                environmentVariables: nodeConfig.environmentVariables,
                documentation: 'Complex workflow with HTTP request node',
                nodeConfigurations: [nodeConfig]
            };

            // Validate the generated project
            const validation = service.validateProjectFiles(generatedProject.files);
            expect(validation.valid).toBe(true);

            // Create ZIP archive
            const zipBuffer = await service.createZipArchive(generatedProject.files);
            expect(zipBuffer).toBeInstanceOf(Buffer);
            expect(zipBuffer.length).toBeGreaterThan(500); // Should be substantial
        });

        it('should handle TypeScript files', async () => {
            const tsFiles: ProjectFile[] = [
                {
                    path: 'src/types.ts',
                    content: `
export interface WorkflowNode {
  id: string;
  type: string;
  parameters: Record<string, any>;
}

export interface ExecutionContext {
  nodeId: string;
  inputData: any[];
}
          `,
                    type: 'typescript'
                },
                {
                    path: 'src/workflow.ts',
                    content: `
import { WorkflowNode, ExecutionContext } from './types';

export class WorkflowExecutor {
  private nodes: Map<string, WorkflowNode> = new Map();
  
  addNode(node: WorkflowNode): void {
    this.nodes.set(node.id, node);
  }
  
  async execute(context: ExecutionContext): Promise<any> {
    // Implementation
    return { success: true };
  }
}
          `,
                    type: 'typescript'
                },
                {
                    path: 'package.json',
                    content: JSON.stringify({
                        name: 'typescript-workflow',
                        scripts: {
                            build: 'tsc',
                            start: 'node dist/workflow.js'
                        },
                        devDependencies: {
                            typescript: '^5.0.0',
                            '@types/node': '^20.0.0'
                        }
                    }),
                    type: 'json'
                },
                {
                    path: 'tsconfig.json',
                    content: JSON.stringify({
                        compilerOptions: {
                            target: 'ES2020',
                            module: 'commonjs',
                            outDir: './dist',
                            rootDir: './src',
                            strict: true
                        }
                    }),
                    type: 'json'
                },
                {
                    path: 'main.js',
                    content: 'require("./dist/workflow.js");',
                    type: 'javascript'
                },
                {
                    path: 'README.md',
                    content: '# TypeScript Workflow\n\nA workflow generated with TypeScript support.',
                    type: 'markdown'
                }
            ];

            const validation = service.validateProjectFiles(tsFiles);
            expect(validation.valid).toBe(true);

            const zipBuffer = await service.createZipArchive(tsFiles);
            expect(zipBuffer).toBeInstanceOf(Buffer);
        });
    });

    describe('Error Handling', () => {
        let service: FileStorageService;

        beforeEach(() => {
            service = new FileStorageService(false);
        });

        it('should handle malformed file structures gracefully', () => {
            const malformedFiles: ProjectFile[] = [
                { path: '', content: 'test', type: 'text' }, // Empty path
                { path: 'valid.js', content: '', type: 'javascript' }, // Empty content
                { path: '../../../etc/passwd', content: 'malicious', type: 'text' } // Path traversal
            ];

            const result = service.validateProjectFiles(malformedFiles);
            expect(result.valid).toBe(false);
            expect(result.errors.length).toBeGreaterThan(0);
        });

        it('should validate file size limits', () => {
            const oversizedContent = 'x'.repeat(15 * 1024 * 1024); // 15MB
            const oversizedFiles: ProjectFile[] = [
                { path: 'package.json', content: '{}', type: 'json' },
                { path: 'huge-file.js', content: oversizedContent, type: 'javascript' },
                { path: 'main.js', content: 'console.log("test");', type: 'javascript' },
                { path: 'README.md', content: '# Test', type: 'markdown' }
            ];

            const result = service.validateProjectFiles(oversizedFiles);
            expect(result.valid).toBe(false);
            expect(result.errors.some(error => error.includes('File too large'))).toBe(true);
        });

        it('should handle ZIP creation errors gracefully', async () => {
            // Test with extremely large number of files to potentially trigger memory issues
            const manyFiles: ProjectFile[] = [];
            for (let i = 0; i < 1000; i++) {
                manyFiles.push({
                    path: `file-${i}.js`,
                    content: `console.log("File ${i}");`,
                    type: 'javascript'
                });
            }

            // This should still work, but we're testing the robustness
            const zipBuffer = await service.createZipArchive(manyFiles);
            expect(zipBuffer).toBeInstanceOf(Buffer);
        });
    });

    describe('Integration with existing methods', () => {
        let service: FileStorageService;

        beforeEach(() => {
            service = new FileStorageService(false);
        });

        it('should maintain compatibility with existing file operations', () => {
            // Verify existing methods still exist
            expect(typeof service.uploadFile).toBe('function');
            expect(typeof service.downloadFile).toBe('function');
            expect(typeof service.getSignedUrl).toBe('function');
            expect(typeof service.deleteFile).toBe('function');
            expect(typeof service.listFiles).toBe('function');
            expect(typeof service.getFileMetadata).toBe('function');
            expect(typeof service.compressFile).toBe('function');
        });

        it('should use correct bucket configurations', () => {
            // Test private methods through reflection or by testing their effects
            const service = new FileStorageService(false);

            // These are private methods, but we can test their behavior indirectly
            // by checking the validation logic they would use
            expect(() => {
                // This would internally call getMaxFileSize and getAllowedMimeTypes
                service.validateProjectFiles([
                    { path: 'test.json', content: '{}', type: 'json' }
                ]);
            }).not.toThrow();
        });
    });
});